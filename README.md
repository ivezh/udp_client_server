**Проект: UDP-сервер для работы с VLAN-MAC таблицей**
---

Сделано по заданию:
- два приложения: клиент и сервер, взаимодействующие через UDP;
- сервер при старте читает файл, хранящий список VLAN-ID + MAC-ADDR в несортированном виде (каждая пара уникальна);
- сервер сортирует этот список и сохраняет его у себя в базе данных в оперативной памяти;
- сервер по запросу от клиента выдаёт N записей из начала базы данных, или следующие N записей от предыдущего запроса этого клиента;
- сервер должен уметь обрабатывать несколько клиентов одновременно, не блокируясь на обработке отдельного клиента, при этом должен быть однопоточным;
- клиент и сервер взаимодействуют по UDP;
- клиент запрашивает у сервера N записей из базы данных, выводит их на экран, ожидает нажатия <q> для завершения или <space> для запроса следующих N записей.

## Архитектура проекта  
- **Сервер**:  
  - Читает CSV-файл с парами `VLAN-ID + MAC-адрес`.  
  - Сортирует данные по VLAN-ID.
  - Обслуживает UDP-запросы клиентов: выдает N записей.
  - Использует `epoll` для обработки множества клиентов в однопоточном режиме.  
- **Клиент**:  
  - Запрашивает данные у сервера.
  - Работает в non-canonical режиме терминала (посимвольная обработка ввода)
  - Поддерживает вывод N записей (`q` — выход, `Space + N` или просто `N` - вывод другого кол-ва пар vlan_id/mac).  

---

## Что реализовано  
1. **Загрузка и хранение данных**:  
   - Чтение CSV-файла построчно. 
   - Хранение данных в массиве структур `VlanMacEntry`.  
2. **Сортировка**:  
   - Реализован алгоритм **counting sort** для сортировки по VLAN-ID.  
   - Позволяет сортировать за `O(N)` за счет использования счетчика и предварительного вычисления индексов.  
3. **UDP-взаимодействие**:  
   - Сервер принимает и обрабатывает UDP-запросы.  
   - Клиент отправляет запросы и выводит полученные данные.  
4. **Однопоточность с epoll**:  
   - Использование `epoll` для асинхронной обработки событий.  
   - Неблокирующий сокет для избежания зависания на одном клиенте.  
5. **Базовая обработка ошибок**:  
   - Проверка корректности входного csv файла.  
   - Ограничение размера пакета до 40 строк в пакете.
6. **Пагинция**   
---

## Что желательно доделать   
- Доимплементировать логику удаления старых клиентов по их unix timestamp в случае отсутствия места для новых, с использованием алгоритма Insertion Sort. Сейчас при заполнении хэш таблицы просто удаляется первый клиент из хранилища.
---

## Описание алгоритма сортировки пар vlan_id/mac
### Используемый метод: **Counting Sort**  
#### Почему выбран:
- VLAN-ID имеют ограниченный диапазон (1–4094, в соответствии с RFC 2674).  
- Counting Sort работает за `O(N + K)`, где `K = 4094`.  

#### Преимущества:  
- Линейная сложность.  
- Минимизация вызовов `malloc` (используется всего 2 выделения памяти).  
---

## Сборка  
### Требования:  
- Компилятор C (например, `gcc`).  
- Библиотеки: `sys/socket.h`, `netinet/in.h`, `arpa/inet.h`.  

### Компиляция:  
- и для клиента и для сервера подготовлены Makefile для сборки

### Запуск:  
```bash
# 1. Генерация CSV с тестовыми данными в папке с сервером
python ./misc generate_csv_vlan_mac.py

# 2. Сервер читает файл vlan_data.csv на старте и выводит номер порта для запуска клиента
./server

# 3. Клиент на старте считывает IP и порт сервера 
./client 127.0.0.1 {server_port}
```